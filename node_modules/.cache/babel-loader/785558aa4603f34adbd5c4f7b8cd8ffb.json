{"ast":null,"code":"var charCodeDef = require('./char-code-definitions');\n\nvar isDigit = charCodeDef.isDigit;\nvar isHexDigit = charCodeDef.isHexDigit;\nvar isUppercaseLetter = charCodeDef.isUppercaseLetter;\nvar isName = charCodeDef.isName;\nvar isWhiteSpace = charCodeDef.isWhiteSpace;\nvar isValidEscape = charCodeDef.isValidEscape;\n\nfunction getCharCode(source, offset) {\n  return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nfunction getNewlineLength(source, offset, code) {\n  if (code === 13\n  /* \\r */\n  && getCharCode(source, offset + 1) === 10\n  /* \\n */\n  ) {\n    return 2;\n  }\n\n  return 1;\n}\n\nfunction cmpChar(testStr, offset, referenceCode) {\n  var code = testStr.charCodeAt(offset); // code.toLowerCase() for A..Z\n\n  if (isUppercaseLetter(code)) {\n    code = code | 32;\n  }\n\n  return code === referenceCode;\n}\n\nfunction cmpStr(testStr, start, end, referenceStr) {\n  if (end - start !== referenceStr.length) {\n    return false;\n  }\n\n  if (start < 0 || end > testStr.length) {\n    return false;\n  }\n\n  for (var i = start; i < end; i++) {\n    var testCode = testStr.charCodeAt(i);\n    var referenceCode = referenceStr.charCodeAt(i - start); // testCode.toLowerCase() for A..Z\n\n    if (isUppercaseLetter(testCode)) {\n      testCode = testCode | 32;\n    }\n\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction findWhiteSpaceStart(source, offset) {\n  for (; offset >= 0; offset--) {\n    if (!isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n\n  return offset + 1;\n}\n\nfunction findWhiteSpaceEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n\n  return offset;\n}\n\nfunction findDecimalNumberEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!isDigit(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n\n  return offset;\n} // § 4.3.7. Consume an escaped code point\n\n\nfunction consumeEscaped(source, offset) {\n  // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n  // that the next input code point has already been verified to be part of a valid escape.\n  offset += 2; // hex digit\n\n  if (isHexDigit(getCharCode(source, offset - 1))) {\n    // Consume as many hex digits as possible, but no more than 5.\n    // Note that this means 1-6 hex digits have been consumed in total.\n    for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n      if (!isHexDigit(getCharCode(source, offset))) {\n        break;\n      }\n    } // If the next input code point is whitespace, consume it as well.\n\n\n    var code = getCharCode(source, offset);\n\n    if (isWhiteSpace(code)) {\n      offset += getNewlineLength(source, offset, code);\n    }\n  }\n\n  return offset;\n} // §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\n\n\nfunction consumeName(source, offset) {\n  // Let result initially be an empty string.\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    var code = source.charCodeAt(offset); // name code point\n\n    if (isName(code)) {\n      // Append the code point to result.\n      continue;\n    } // the stream starts with a valid escape\n\n\n    if (isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point. Append the returned code point to result.\n      offset = consumeEscaped(source, offset) - 1;\n      continue;\n    } // anything else\n    // Reconsume the current input code point. Return result.\n\n\n    break;\n  }\n\n  return offset;\n} // §4.3.12. Consume a number\n\n\nfunction consumeNumber(source, offset) {\n  var code = source.charCodeAt(offset); // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n  // consume it and append it to repr.\n\n  if (code === 0x002B || code === 0x002D) {\n    code = source.charCodeAt(offset += 1);\n  } // 3. While the next input code point is a digit, consume it and append it to repr.\n\n\n  if (isDigit(code)) {\n    offset = findDecimalNumberEnd(source, offset + 1);\n    code = source.charCodeAt(offset);\n  } // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n\n\n  if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n    // 4.1 Consume them.\n    // 4.2 Append them to repr.\n    code = source.charCodeAt(offset += 2); // 4.3 Set type to \"number\".\n    // TODO\n    // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n    offset = findDecimalNumberEnd(source, offset);\n  } // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n\n\n  if (cmpChar(source, offset, 101\n  /* e */\n  )) {\n    var sign = 0;\n    code = source.charCodeAt(offset + 1); // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n\n    if (code === 0x002D || code === 0x002B) {\n      sign = 1;\n      code = source.charCodeAt(offset + 2);\n    } // ... followed by a digit\n\n\n    if (isDigit(code)) {\n      // 5.1 Consume them.\n      // 5.2 Append them to repr.\n      // 5.3 Set type to \"number\".\n      // TODO\n      // 5.4 While the next input code point is a digit, consume it and append it to repr.\n      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n    }\n  }\n\n  return offset;\n} // § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\n\n\nfunction consumeBadUrlRemnants(source, offset) {\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    var code = source.charCodeAt(offset); // U+0029 RIGHT PARENTHESIS ())\n    // EOF\n\n    if (code === 0x0029) {\n      // Return.\n      offset++;\n      break;\n    }\n\n    if (isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point.\n      // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n      // without ending the <bad-url-token>. This is otherwise identical to\n      // the \"anything else\" clause.\n      offset = consumeEscaped(source, offset);\n    }\n  }\n\n  return offset;\n}\n\nmodule.exports = {\n  consumeEscaped: consumeEscaped,\n  consumeName: consumeName,\n  consumeNumber: consumeNumber,\n  consumeBadUrlRemnants: consumeBadUrlRemnants,\n  cmpChar: cmpChar,\n  cmpStr: cmpStr,\n  getNewlineLength: getNewlineLength,\n  findWhiteSpaceStart: findWhiteSpaceStart,\n  findWhiteSpaceEnd: findWhiteSpaceEnd\n};","map":{"version":3,"names":["charCodeDef","require","isDigit","isHexDigit","isUppercaseLetter","isName","isWhiteSpace","isValidEscape","getCharCode","source","offset","length","charCodeAt","getNewlineLength","code","cmpChar","testStr","referenceCode","cmpStr","start","end","referenceStr","i","testCode","findWhiteSpaceStart","findWhiteSpaceEnd","findDecimalNumberEnd","consumeEscaped","maxOffset","Math","min","consumeName","consumeNumber","sign","consumeBadUrlRemnants","module","exports"],"sources":["/Users/nedanemati/Desktop/material-ui-github/node_modules/css-tree/lib/tokenizer/utils.js"],"sourcesContent":["var charCodeDef = require('./char-code-definitions');\nvar isDigit = charCodeDef.isDigit;\nvar isHexDigit = charCodeDef.isHexDigit;\nvar isUppercaseLetter = charCodeDef.isUppercaseLetter;\nvar isName = charCodeDef.isName;\nvar isWhiteSpace = charCodeDef.isWhiteSpace;\nvar isValidEscape = charCodeDef.isValidEscape;\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nfunction getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nfunction cmpChar(testStr, offset, referenceCode) {\n    var code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nfunction cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (var i = start; i < end; i++) {\n        var testCode = testStr.charCodeAt(i);\n        var referenceCode = referenceStr.charCodeAt(i - start);\n\n        // testCode.toLowerCase() for A..Z\n        if (isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nfunction findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nfunction findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nfunction consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        var code = getCharCode(source, offset);\n        if (isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nfunction consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        var code = source.charCodeAt(offset);\n\n        // name code point\n        if (isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// §4.3.12. Consume a number\nfunction consumeNumber(source, offset) {\n    var code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        code = source.charCodeAt(offset += 2);\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        var sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nfunction consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        var code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\nmodule.exports = {\n    consumeEscaped: consumeEscaped,\n    consumeName: consumeName,\n    consumeNumber: consumeNumber,\n    consumeBadUrlRemnants: consumeBadUrlRemnants,\n\n    cmpChar: cmpChar,\n    cmpStr: cmpStr,\n\n    getNewlineLength: getNewlineLength,\n    findWhiteSpaceStart: findWhiteSpaceStart,\n    findWhiteSpaceEnd: findWhiteSpaceEnd\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}