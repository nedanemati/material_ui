{"ast":null,"code":"var List = require('../common/List');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isValidNumber(value) {\n  // Number.isInteger(value) && value >= 0\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value && value >= 0;\n}\n\nfunction isValidLocation(loc) {\n  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);\n}\n\nfunction createNodeStructureChecker(type, fields) {\n  return function checkNode(node, warn) {\n    if (!node || node.constructor !== Object) {\n      return warn(node, 'Type of node should be an Object');\n    }\n\n    for (var key in node) {\n      var valid = true;\n\n      if (hasOwnProperty.call(node, key) === false) {\n        continue;\n      }\n\n      if (key === 'type') {\n        if (node.type !== type) {\n          warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n        }\n      } else if (key === 'loc') {\n        if (node.loc === null) {\n          continue;\n        } else if (node.loc && node.loc.constructor === Object) {\n          if (typeof node.loc.source !== 'string') {\n            key += '.source';\n          } else if (!isValidLocation(node.loc.start)) {\n            key += '.start';\n          } else if (!isValidLocation(node.loc.end)) {\n            key += '.end';\n          } else {\n            continue;\n          }\n        }\n\n        valid = false;\n      } else if (fields.hasOwnProperty(key)) {\n        for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {\n          var fieldType = fields[key][i];\n\n          switch (fieldType) {\n            case String:\n              valid = typeof node[key] === 'string';\n              break;\n\n            case Boolean:\n              valid = typeof node[key] === 'boolean';\n              break;\n\n            case null:\n              valid = node[key] === null;\n              break;\n\n            default:\n              if (typeof fieldType === 'string') {\n                valid = node[key] && node[key].type === fieldType;\n              } else if (Array.isArray(fieldType)) {\n                valid = node[key] instanceof List;\n              }\n\n          }\n        }\n      } else {\n        warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n      }\n\n      if (!valid) {\n        warn(node, 'Bad value for `' + type + '.' + key + '`');\n      }\n    }\n\n    for (var key in fields) {\n      if (hasOwnProperty.call(fields, key) && hasOwnProperty.call(node, key) === false) {\n        warn(node, 'Field `' + type + '.' + key + '` is missed');\n      }\n    }\n  };\n}\n\nfunction processStructure(name, nodeType) {\n  var structure = nodeType.structure;\n  var fields = {\n    type: String,\n    loc: true\n  };\n  var docs = {\n    type: '\"' + name + '\"'\n  };\n\n  for (var key in structure) {\n    if (hasOwnProperty.call(structure, key) === false) {\n      continue;\n    }\n\n    var docsTypes = [];\n    var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];\n\n    for (var i = 0; i < fieldTypes.length; i++) {\n      var fieldType = fieldTypes[i];\n\n      if (fieldType === String || fieldType === Boolean) {\n        docsTypes.push(fieldType.name);\n      } else if (fieldType === null) {\n        docsTypes.push('null');\n      } else if (typeof fieldType === 'string') {\n        docsTypes.push('<' + fieldType + '>');\n      } else if (Array.isArray(fieldType)) {\n        docsTypes.push('List'); // TODO: use type enum\n      } else {\n        throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n      }\n    }\n\n    docs[key] = docsTypes.join(' | ');\n  }\n\n  return {\n    docs: docs,\n    check: createNodeStructureChecker(name, fields)\n  };\n}\n\nmodule.exports = {\n  getStructureFromConfig: function (config) {\n    var structure = {};\n\n    if (config.node) {\n      for (var name in config.node) {\n        if (hasOwnProperty.call(config.node, name)) {\n          var nodeType = config.node[name];\n\n          if (nodeType.structure) {\n            structure[name] = processStructure(name, nodeType);\n          } else {\n            throw new Error('Missed `structure` field in `' + name + '` node type definition');\n          }\n        }\n      }\n    }\n\n    return structure;\n  }\n};","map":{"version":3,"names":["List","require","hasOwnProperty","Object","prototype","isValidNumber","value","isFinite","Math","floor","isValidLocation","loc","Boolean","offset","line","column","createNodeStructureChecker","type","fields","checkNode","node","warn","constructor","key","valid","call","source","start","end","i","length","fieldType","String","Array","isArray","processStructure","name","nodeType","structure","docs","docsTypes","fieldTypes","slice","push","Error","join","check","module","exports","getStructureFromConfig","config"],"sources":["/Users/nedanemati/Desktop/material-ui-github/node_modules/css-tree/lib/lexer/structure.js"],"sourcesContent":["var List = require('../common/List');\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isValidNumber(value) {\n    // Number.isInteger(value) && value >= 0\n    return (\n        typeof value === 'number' &&\n        isFinite(value) &&\n        Math.floor(value) === value &&\n        value >= 0\n    );\n}\n\nfunction isValidLocation(loc) {\n    return (\n        Boolean(loc) &&\n        isValidNumber(loc.offset) &&\n        isValidNumber(loc.line) &&\n        isValidNumber(loc.column)\n    );\n}\n\nfunction createNodeStructureChecker(type, fields) {\n    return function checkNode(node, warn) {\n        if (!node || node.constructor !== Object) {\n            return warn(node, 'Type of node should be an Object');\n        }\n\n        for (var key in node) {\n            var valid = true;\n\n            if (hasOwnProperty.call(node, key) === false) {\n                continue;\n            }\n\n            if (key === 'type') {\n                if (node.type !== type) {\n                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n                }\n            } else if (key === 'loc') {\n                if (node.loc === null) {\n                    continue;\n                } else if (node.loc && node.loc.constructor === Object) {\n                    if (typeof node.loc.source !== 'string') {\n                        key += '.source';\n                    } else if (!isValidLocation(node.loc.start)) {\n                        key += '.start';\n                    } else if (!isValidLocation(node.loc.end)) {\n                        key += '.end';\n                    } else {\n                        continue;\n                    }\n                }\n\n                valid = false;\n            } else if (fields.hasOwnProperty(key)) {\n                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {\n                    var fieldType = fields[key][i];\n\n                    switch (fieldType) {\n                        case String:\n                            valid = typeof node[key] === 'string';\n                            break;\n\n                        case Boolean:\n                            valid = typeof node[key] === 'boolean';\n                            break;\n\n                        case null:\n                            valid = node[key] === null;\n                            break;\n\n                        default:\n                            if (typeof fieldType === 'string') {\n                                valid = node[key] && node[key].type === fieldType;\n                            } else if (Array.isArray(fieldType)) {\n                                valid = node[key] instanceof List;\n                            }\n                    }\n                }\n            } else {\n                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n            }\n\n            if (!valid) {\n                warn(node, 'Bad value for `' + type + '.' + key + '`');\n            }\n        }\n\n        for (var key in fields) {\n            if (hasOwnProperty.call(fields, key) &&\n                hasOwnProperty.call(node, key) === false) {\n                warn(node, 'Field `' + type + '.' + key + '` is missed');\n            }\n        }\n    };\n}\n\nfunction processStructure(name, nodeType) {\n    var structure = nodeType.structure;\n    var fields = {\n        type: String,\n        loc: true\n    };\n    var docs = {\n        type: '\"' + name + '\"'\n    };\n\n    for (var key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        var docsTypes = [];\n        var fieldTypes = fields[key] = Array.isArray(structure[key])\n            ? structure[key].slice()\n            : [structure[key]];\n\n        for (var i = 0; i < fieldTypes.length; i++) {\n            var fieldType = fieldTypes[i];\n            if (fieldType === String || fieldType === Boolean) {\n                docsTypes.push(fieldType.name);\n            } else if (fieldType === null) {\n                docsTypes.push('null');\n            } else if (typeof fieldType === 'string') {\n                docsTypes.push('<' + fieldType + '>');\n            } else if (Array.isArray(fieldType)) {\n                docsTypes.push('List'); // TODO: use type enum\n            } else {\n                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n            }\n        }\n\n        docs[key] = docsTypes.join(' | ');\n    }\n\n    return {\n        docs: docs,\n        check: createNodeStructureChecker(name, fields)\n    };\n}\n\nmodule.exports = {\n    getStructureFromConfig: function(config) {\n        var structure = {};\n\n        if (config.node) {\n            for (var name in config.node) {\n                if (hasOwnProperty.call(config.node, name)) {\n                    var nodeType = config.node[name];\n\n                    if (nodeType.structure) {\n                        structure[name] = processStructure(name, nodeType);\n                    } else {\n                        throw new Error('Missed `structure` field in `' + name + '` node type definition');\n                    }\n                }\n            }\n        }\n\n        return structure;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}