{"ast":null,"code":"var parse = require('../definition-syntax/parse');\n\nvar MATCH = {\n  type: 'Match'\n};\nvar MISMATCH = {\n  type: 'Mismatch'\n};\nvar DISALLOW_EMPTY = {\n  type: 'DisallowEmpty'\n};\nvar LEFTPARENTHESIS = 40; // (\n\nvar RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n  // reduce node count\n  if (thenBranch === MATCH && elseBranch === MISMATCH) {\n    return match;\n  }\n\n  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n    return match;\n  }\n\n  if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n    thenBranch = match.then;\n    match = match.match;\n  }\n\n  return {\n    type: 'If',\n    match: match,\n    then: thenBranch,\n    else: elseBranch\n  };\n}\n\nfunction isFunctionType(name) {\n  return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;\n}\n\nfunction isEnumCapatible(term) {\n  return term.type === 'Keyword' || term.type === 'AtKeyword' || term.type === 'Function' || term.type === 'Type' && isFunctionType(term.name);\n}\n\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n  switch (combinator) {\n    case ' ':\n      // Juxtaposing components means that all of them must occur, in the given order.\n      //\n      // a b c\n      // =\n      // match a\n      //   then match b\n      //     then match c\n      //       then MATCH\n      //       else MISMATCH\n      //     else MISMATCH\n      //   else MISMATCH\n      var result = MATCH;\n\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        result = createCondition(term, result, MISMATCH);\n      }\n\n      ;\n      return result;\n\n    case '|':\n      // A bar (|) separates two or more alternatives: exactly one of them must occur.\n      //\n      // a | b | c\n      // =\n      // match a\n      //   then MATCH\n      //   else match b\n      //     then MATCH\n      //     else match c\n      //       then MATCH\n      //       else MISMATCH\n      var result = MISMATCH;\n      var map = null;\n\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i]; // reduce sequence of keywords into a Enum\n\n        if (isEnumCapatible(term)) {\n          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n            map = Object.create(null);\n            result = createCondition({\n              type: 'Enum',\n              map: map\n            }, MATCH, result);\n          }\n\n          if (map !== null) {\n            var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n\n            if (key in map === false) {\n              map[key] = term;\n              continue;\n            }\n          }\n        }\n\n        map = null; // create a new conditonal node\n\n        result = createCondition(term, MATCH, result);\n      }\n\n      ;\n      return result;\n\n    case '&&':\n      // A double ampersand (&&) separates two or more components,\n      // all of which must occur, in any order.\n      // Use MatchOnce for groups with a large number of terms,\n      // since &&-groups produces at least N!-node trees\n      if (terms.length > 5) {\n        return {\n          type: 'MatchOnce',\n          terms: terms,\n          all: true\n        };\n      } // Use a combination tree for groups with small number of terms\n      //\n      // a && b && c\n      // =\n      // match a\n      //   then [b && c]\n      //   else match b\n      //     then [a && c]\n      //     else match c\n      //       then [a && b]\n      //       else MISMATCH\n      //\n      // a && b\n      // =\n      // match a\n      //   then match b\n      //     then MATCH\n      //     else MISMATCH\n      //   else match b\n      //     then match a\n      //       then MATCH\n      //       else MISMATCH\n      //     else MISMATCH\n\n\n      var result = MISMATCH;\n\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        var thenClause;\n\n        if (terms.length > 1) {\n          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {\n            return newGroupTerm !== term;\n          }), false);\n        } else {\n          thenClause = MATCH;\n        }\n\n        result = createCondition(term, thenClause, result);\n      }\n\n      ;\n      return result;\n\n    case '||':\n      // A double bar (||) separates two or more options:\n      // one or more of them must occur, in any order.\n      // Use MatchOnce for groups with a large number of terms,\n      // since ||-groups produces at least N!-node trees\n      if (terms.length > 5) {\n        return {\n          type: 'MatchOnce',\n          terms: terms,\n          all: false\n        };\n      } // Use a combination tree for groups with small number of terms\n      //\n      // a || b || c\n      // =\n      // match a\n      //   then [b || c]\n      //   else match b\n      //     then [a || c]\n      //     else match c\n      //       then [a || b]\n      //       else MISMATCH\n      //\n      // a || b\n      // =\n      // match a\n      //   then match b\n      //     then MATCH\n      //     else MATCH\n      //   else match b\n      //     then match a\n      //       then MATCH\n      //       else MATCH\n      //     else MISMATCH\n\n\n      var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        var thenClause;\n\n        if (terms.length > 1) {\n          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {\n            return newGroupTerm !== term;\n          }), true);\n        } else {\n          thenClause = MATCH;\n        }\n\n        result = createCondition(term, thenClause, result);\n      }\n\n      ;\n      return result;\n  }\n}\n\nfunction buildMultiplierMatchGraph(node) {\n  var result = MATCH;\n  var matchTerm = buildMatchGraph(node.term);\n\n  if (node.max === 0) {\n    // disable repeating of empty match to prevent infinite loop\n    matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH); // an occurrence count is not limited, make a cycle;\n    // to collect more terms on each following matching mismatch\n\n    result = createCondition(matchTerm, null, // will be a loop\n    MISMATCH);\n    result.then = createCondition(MATCH, MATCH, result // make a loop\n    );\n\n    if (node.comma) {\n      result.then.else = createCondition({\n        type: 'Comma',\n        syntax: node\n      }, result, MISMATCH);\n    }\n  } else {\n    // create a match node chain for [min .. max] interval with optional matches\n    for (var i = node.min || 1; i <= node.max; i++) {\n      if (node.comma && result !== MATCH) {\n        result = createCondition({\n          type: 'Comma',\n          syntax: node\n        }, result, MISMATCH);\n      }\n\n      result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);\n    }\n  }\n\n  if (node.min === 0) {\n    // allow zero match\n    result = createCondition(MATCH, MATCH, result);\n  } else {\n    // create a match node chain to collect [0 ... min - 1] required matches\n    for (var i = 0; i < node.min - 1; i++) {\n      if (node.comma && result !== MATCH) {\n        result = createCondition({\n          type: 'Comma',\n          syntax: node\n        }, result, MISMATCH);\n      }\n\n      result = createCondition(matchTerm, result, MISMATCH);\n    }\n  }\n\n  return result;\n}\n\nfunction buildMatchGraph(node) {\n  if (typeof node === 'function') {\n    return {\n      type: 'Generic',\n      fn: node\n    };\n  }\n\n  switch (node.type) {\n    case 'Group':\n      var result = buildGroupMatchGraph(node.combinator, node.terms.map(buildMatchGraph), false);\n\n      if (node.disallowEmpty) {\n        result = createCondition(result, DISALLOW_EMPTY, MISMATCH);\n      }\n\n      return result;\n\n    case 'Multiplier':\n      return buildMultiplierMatchGraph(node);\n\n    case 'Type':\n    case 'Property':\n      return {\n        type: node.type,\n        name: node.name,\n        syntax: node\n      };\n\n    case 'Keyword':\n      return {\n        type: node.type,\n        name: node.name.toLowerCase(),\n        syntax: node\n      };\n\n    case 'AtKeyword':\n      return {\n        type: node.type,\n        name: '@' + node.name.toLowerCase(),\n        syntax: node\n      };\n\n    case 'Function':\n      return {\n        type: node.type,\n        name: node.name.toLowerCase() + '(',\n        syntax: node\n      };\n\n    case 'String':\n      // convert a one char length String to a Token\n      if (node.value.length === 3) {\n        return {\n          type: 'Token',\n          value: node.value.charAt(1),\n          syntax: node\n        };\n      } // otherwise use it as is\n\n\n      return {\n        type: node.type,\n        value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n        syntax: node\n      };\n\n    case 'Token':\n      return {\n        type: node.type,\n        value: node.value,\n        syntax: node\n      };\n\n    case 'Comma':\n      return {\n        type: node.type,\n        syntax: node\n      };\n\n    default:\n      throw new Error('Unknown node type:', node.type);\n  }\n}\n\nmodule.exports = {\n  MATCH: MATCH,\n  MISMATCH: MISMATCH,\n  DISALLOW_EMPTY: DISALLOW_EMPTY,\n  buildMatchGraph: function (syntaxTree, ref) {\n    if (typeof syntaxTree === 'string') {\n      syntaxTree = parse(syntaxTree);\n    }\n\n    return {\n      type: 'MatchGraph',\n      match: buildMatchGraph(syntaxTree),\n      syntax: ref || null,\n      source: syntaxTree\n    };\n  }\n};","map":{"version":3,"names":["parse","require","MATCH","type","MISMATCH","DISALLOW_EMPTY","LEFTPARENTHESIS","RIGHTPARENTHESIS","createCondition","match","thenBranch","elseBranch","else","then","isFunctionType","name","length","charCodeAt","isEnumCapatible","term","buildGroupMatchGraph","combinator","terms","atLeastOneTermMatched","result","i","map","Object","create","key","slice","toLowerCase","all","thenClause","filter","newGroupTerm","buildMultiplierMatchGraph","node","matchTerm","buildMatchGraph","max","comma","syntax","min","fn","disallowEmpty","value","charAt","substr","replace","Error","module","exports","syntaxTree","ref","source"],"sources":["/Users/nedanemati/Desktop/material-ui-github/node_modules/css-tree/lib/lexer/match-graph.js"],"sourcesContent":["var parse = require('../definition-syntax/parse');\n\nvar MATCH = { type: 'Match' };\nvar MISMATCH = { type: 'Mismatch' };\nvar DISALLOW_EMPTY = { type: 'DisallowEmpty' };\nvar LEFTPARENTHESIS = 40;  // (\nvar RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n    // reduce node count\n    if (thenBranch === MATCH && elseBranch === MISMATCH) {\n        return match;\n    }\n\n    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n        return match;\n    }\n\n    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n        thenBranch = match.then;\n        match = match.match;\n    }\n\n    return {\n        type: 'If',\n        match: match,\n        then: thenBranch,\n        else: elseBranch\n    };\n}\n\nfunction isFunctionType(name) {\n    return (\n        name.length > 2 &&\n        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&\n        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS\n    );\n}\n\nfunction isEnumCapatible(term) {\n    return (\n        term.type === 'Keyword' ||\n        term.type === 'AtKeyword' ||\n        term.type === 'Function' ||\n        term.type === 'Type' && isFunctionType(term.name)\n    );\n}\n\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n    switch (combinator) {\n        case ' ':\n            // Juxtaposing components means that all of them must occur, in the given order.\n            //\n            // a b c\n            // =\n            // match a\n            //   then match b\n            //     then match c\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            //   else MISMATCH\n            var result = MATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n\n                result = createCondition(\n                    term,\n                    result,\n                    MISMATCH\n                );\n            };\n\n            return result;\n\n        case '|':\n            // A bar (|) separates two or more alternatives: exactly one of them must occur.\n            //\n            // a | b | c\n            // =\n            // match a\n            //   then MATCH\n            //   else match b\n            //     then MATCH\n            //     else match c\n            //       then MATCH\n            //       else MISMATCH\n\n            var result = MISMATCH;\n            var map = null;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n\n                // reduce sequence of keywords into a Enum\n                if (isEnumCapatible(term)) {\n                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n                        map = Object.create(null);\n                        result = createCondition(\n                            {\n                                type: 'Enum',\n                                map: map\n                            },\n                            MATCH,\n                            result\n                        );\n                    }\n\n                    if (map !== null) {\n                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n                        if (key in map === false) {\n                            map[key] = term;\n                            continue;\n                        }\n                    }\n                }\n\n                map = null;\n\n                // create a new conditonal node\n                result = createCondition(\n                    term,\n                    MATCH,\n                    result\n                );\n            };\n\n            return result;\n\n        case '&&':\n            // A double ampersand (&&) separates two or more components,\n            // all of which must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since &&-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms: terms,\n                    all: true\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a && b && c\n            // =\n            // match a\n            //   then [b && c]\n            //   else match b\n            //     then [a && c]\n            //     else match c\n            //       then [a && b]\n            //       else MISMATCH\n            //\n            // a && b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MISMATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            var result = MISMATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n                var thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        false\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n\n        case '||':\n            // A double bar (||) separates two or more options:\n            // one or more of them must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since ||-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms: terms,\n                    all: false\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a || b || c\n            // =\n            // match a\n            //   then [b || c]\n            //   else match b\n            //     then [a || c]\n            //     else match c\n            //       then [a || b]\n            //       else MISMATCH\n            //\n            // a || b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MATCH\n            //     else MISMATCH\n            var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n                var thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        true\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n    }\n}\n\nfunction buildMultiplierMatchGraph(node) {\n    var result = MATCH;\n    var matchTerm = buildMatchGraph(node.term);\n\n    if (node.max === 0) {\n        // disable repeating of empty match to prevent infinite loop\n        matchTerm = createCondition(\n            matchTerm,\n            DISALLOW_EMPTY,\n            MISMATCH\n        );\n\n        // an occurrence count is not limited, make a cycle;\n        // to collect more terms on each following matching mismatch\n        result = createCondition(\n            matchTerm,\n            null, // will be a loop\n            MISMATCH\n        );\n\n        result.then = createCondition(\n            MATCH,\n            MATCH,\n            result // make a loop\n        );\n\n        if (node.comma) {\n            result.then.else = createCondition(\n                { type: 'Comma', syntax: node },\n                result,\n                MISMATCH\n            );\n        }\n    } else {\n        // create a match node chain for [min .. max] interval with optional matches\n        for (var i = node.min || 1; i <= node.max; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                createCondition(\n                    MATCH,\n                    MATCH,\n                    result\n                ),\n                MISMATCH\n            );\n        }\n    }\n\n    if (node.min === 0) {\n        // allow zero match\n        result = createCondition(\n            MATCH,\n            MATCH,\n            result\n        );\n    } else {\n        // create a match node chain to collect [0 ... min - 1] required matches\n        for (var i = 0; i < node.min - 1; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                result,\n                MISMATCH\n            );\n        }\n    }\n\n    return result;\n}\n\nfunction buildMatchGraph(node) {\n    if (typeof node === 'function') {\n        return {\n            type: 'Generic',\n            fn: node\n        };\n    }\n\n    switch (node.type) {\n        case 'Group':\n            var result = buildGroupMatchGraph(\n                node.combinator,\n                node.terms.map(buildMatchGraph),\n                false\n            );\n\n            if (node.disallowEmpty) {\n                result = createCondition(\n                    result,\n                    DISALLOW_EMPTY,\n                    MISMATCH\n                );\n            }\n\n            return result;\n\n        case 'Multiplier':\n            return buildMultiplierMatchGraph(node);\n\n        case 'Type':\n        case 'Property':\n            return {\n                type: node.type,\n                name: node.name,\n                syntax: node\n            };\n\n        case 'Keyword':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'AtKeyword':\n            return {\n                type: node.type,\n                name: '@' + node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'Function':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase() + '(',\n                syntax: node\n            };\n\n        case 'String':\n            // convert a one char length String to a Token\n            if (node.value.length === 3) {\n                return {\n                    type: 'Token',\n                    value: node.value.charAt(1),\n                    syntax: node\n                };\n            }\n\n            // otherwise use it as is\n            return {\n                type: node.type,\n                value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n                syntax: node\n            };\n\n        case 'Token':\n            return {\n                type: node.type,\n                value: node.value,\n                syntax: node\n            };\n\n        case 'Comma':\n            return {\n                type: node.type,\n                syntax: node\n            };\n\n        default:\n            throw new Error('Unknown node type:', node.type);\n    }\n}\n\nmodule.exports = {\n    MATCH: MATCH,\n    MISMATCH: MISMATCH,\n    DISALLOW_EMPTY: DISALLOW_EMPTY,\n    buildMatchGraph: function(syntaxTree, ref) {\n        if (typeof syntaxTree === 'string') {\n            syntaxTree = parse(syntaxTree);\n        }\n\n        return {\n            type: 'MatchGraph',\n            match: buildMatchGraph(syntaxTree),\n            syntax: ref || null,\n            source: syntaxTree\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}