{"ast":null,"code":"var Tokenizer = require('./tokenizer');\n\nvar TAB = 9;\nvar N = 10;\nvar F = 12;\nvar R = 13;\nvar SPACE = 32;\nvar EXCLAMATIONMARK = 33; // !\n\nvar NUMBERSIGN = 35; // #\n\nvar AMPERSAND = 38; // &\n\nvar APOSTROPHE = 39; // '\n\nvar LEFTPARENTHESIS = 40; // (\n\nvar RIGHTPARENTHESIS = 41; // )\n\nvar ASTERISK = 42; // *\n\nvar PLUSSIGN = 43; // +\n\nvar COMMA = 44; // ,\n\nvar HYPERMINUS = 45; // -\n\nvar LESSTHANSIGN = 60; // <\n\nvar GREATERTHANSIGN = 62; // >\n\nvar QUESTIONMARK = 63; // ?\n\nvar COMMERCIALAT = 64; // @\n\nvar LEFTSQUAREBRACKET = 91; // [\n\nvar RIGHTSQUAREBRACKET = 93; // ]\n\nvar LEFTCURLYBRACKET = 123; // {\n\nvar VERTICALLINE = 124; // |\n\nvar RIGHTCURLYBRACKET = 125; // }\n\nvar INFINITY = 8734; // ∞\n\nvar NAME_CHAR = createCharMap(function (ch) {\n  return /[a-zA-Z0-9\\-]/.test(ch);\n});\nvar COMBINATOR_PRECEDENCE = {\n  ' ': 1,\n  '&&': 2,\n  '||': 3,\n  '|': 4\n};\n\nfunction createCharMap(fn) {\n  var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);\n\n  for (var i = 0; i < 128; i++) {\n    array[i] = fn(String.fromCharCode(i)) ? 1 : 0;\n  }\n\n  return array;\n}\n\nfunction scanSpaces(tokenizer) {\n  return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));\n}\n\nfunction scanWord(tokenizer) {\n  var end = tokenizer.pos;\n\n  for (; end < tokenizer.str.length; end++) {\n    var code = tokenizer.str.charCodeAt(end);\n\n    if (code >= 128 || NAME_CHAR[code] === 0) {\n      break;\n    }\n  }\n\n  if (tokenizer.pos === end) {\n    tokenizer.error('Expect a keyword');\n  }\n\n  return tokenizer.substringToPos(end);\n}\n\nfunction scanNumber(tokenizer) {\n  var end = tokenizer.pos;\n\n  for (; end < tokenizer.str.length; end++) {\n    var code = tokenizer.str.charCodeAt(end);\n\n    if (code < 48 || code > 57) {\n      break;\n    }\n  }\n\n  if (tokenizer.pos === end) {\n    tokenizer.error('Expect a number');\n  }\n\n  return tokenizer.substringToPos(end);\n}\n\nfunction scanString(tokenizer) {\n  var end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n\n  if (end === -1) {\n    tokenizer.pos = tokenizer.str.length;\n    tokenizer.error('Expect an apostrophe');\n  }\n\n  return tokenizer.substringToPos(end + 1);\n}\n\nfunction readMultiplierRange(tokenizer) {\n  var min = null;\n  var max = null;\n  tokenizer.eat(LEFTCURLYBRACKET);\n  min = scanNumber(tokenizer);\n\n  if (tokenizer.charCode() === COMMA) {\n    tokenizer.pos++;\n\n    if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n      max = scanNumber(tokenizer);\n    }\n  } else {\n    max = min;\n  }\n\n  tokenizer.eat(RIGHTCURLYBRACKET);\n  return {\n    min: Number(min),\n    max: max ? Number(max) : 0\n  };\n}\n\nfunction readMultiplier(tokenizer) {\n  var range = null;\n  var comma = false;\n\n  switch (tokenizer.charCode()) {\n    case ASTERISK:\n      tokenizer.pos++;\n      range = {\n        min: 0,\n        max: 0\n      };\n      break;\n\n    case PLUSSIGN:\n      tokenizer.pos++;\n      range = {\n        min: 1,\n        max: 0\n      };\n      break;\n\n    case QUESTIONMARK:\n      tokenizer.pos++;\n      range = {\n        min: 0,\n        max: 1\n      };\n      break;\n\n    case NUMBERSIGN:\n      tokenizer.pos++;\n      comma = true;\n\n      if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n        range = readMultiplierRange(tokenizer);\n      } else {\n        range = {\n          min: 1,\n          max: 0\n        };\n      }\n\n      break;\n\n    case LEFTCURLYBRACKET:\n      range = readMultiplierRange(tokenizer);\n      break;\n\n    default:\n      return null;\n  }\n\n  return {\n    type: 'Multiplier',\n    comma: comma,\n    min: range.min,\n    max: range.max,\n    term: null\n  };\n}\n\nfunction maybeMultiplied(tokenizer, node) {\n  var multiplier = readMultiplier(tokenizer);\n\n  if (multiplier !== null) {\n    multiplier.term = node;\n    return multiplier;\n  }\n\n  return node;\n}\n\nfunction maybeToken(tokenizer) {\n  var ch = tokenizer.peek();\n\n  if (ch === '') {\n    return null;\n  }\n\n  return {\n    type: 'Token',\n    value: ch\n  };\n}\n\nfunction readProperty(tokenizer) {\n  var name;\n  tokenizer.eat(LESSTHANSIGN);\n  tokenizer.eat(APOSTROPHE);\n  name = scanWord(tokenizer);\n  tokenizer.eat(APOSTROPHE);\n  tokenizer.eat(GREATERTHANSIGN);\n  return maybeMultiplied(tokenizer, {\n    type: 'Property',\n    name: name\n  });\n} // https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation—[min,max]—within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\n\n\nfunction readTypeRange(tokenizer) {\n  // use null for Infinity to make AST format JSON serializable/deserializable\n  var min = null; // -Infinity\n\n  var max = null; // Infinity\n\n  var sign = 1;\n  tokenizer.eat(LEFTSQUAREBRACKET);\n\n  if (tokenizer.charCode() === HYPERMINUS) {\n    tokenizer.peek();\n    sign = -1;\n  }\n\n  if (sign == -1 && tokenizer.charCode() === INFINITY) {\n    tokenizer.peek();\n  } else {\n    min = sign * Number(scanNumber(tokenizer));\n  }\n\n  scanSpaces(tokenizer);\n  tokenizer.eat(COMMA);\n  scanSpaces(tokenizer);\n\n  if (tokenizer.charCode() === INFINITY) {\n    tokenizer.peek();\n  } else {\n    sign = 1;\n\n    if (tokenizer.charCode() === HYPERMINUS) {\n      tokenizer.peek();\n      sign = -1;\n    }\n\n    max = sign * Number(scanNumber(tokenizer));\n  }\n\n  tokenizer.eat(RIGHTSQUAREBRACKET); // If no range is indicated, either by using the bracketed range notation\n  // or in the property description, then [−∞,∞] is assumed.\n\n  if (min === null && max === null) {\n    return null;\n  }\n\n  return {\n    type: 'Range',\n    min: min,\n    max: max\n  };\n}\n\nfunction readType(tokenizer) {\n  var name;\n  var opts = null;\n  tokenizer.eat(LESSTHANSIGN);\n  name = scanWord(tokenizer);\n\n  if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n    tokenizer.pos += 2;\n    name += '()';\n  }\n\n  if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n    scanSpaces(tokenizer);\n    opts = readTypeRange(tokenizer);\n  }\n\n  tokenizer.eat(GREATERTHANSIGN);\n  return maybeMultiplied(tokenizer, {\n    type: 'Type',\n    name: name,\n    opts: opts\n  });\n}\n\nfunction readKeywordOrFunction(tokenizer) {\n  var name;\n  name = scanWord(tokenizer);\n\n  if (tokenizer.charCode() === LEFTPARENTHESIS) {\n    tokenizer.pos++;\n    return {\n      type: 'Function',\n      name: name\n    };\n  }\n\n  return maybeMultiplied(tokenizer, {\n    type: 'Keyword',\n    name: name\n  });\n}\n\nfunction regroupTerms(terms, combinators) {\n  function createGroup(terms, combinator) {\n    return {\n      type: 'Group',\n      terms: terms,\n      combinator: combinator,\n      disallowEmpty: false,\n      explicit: false\n    };\n  }\n\n  combinators = Object.keys(combinators).sort(function (a, b) {\n    return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];\n  });\n\n  while (combinators.length > 0) {\n    var combinator = combinators.shift();\n\n    for (var i = 0, subgroupStart = 0; i < terms.length; i++) {\n      var term = terms[i];\n\n      if (term.type === 'Combinator') {\n        if (term.value === combinator) {\n          if (subgroupStart === -1) {\n            subgroupStart = i - 1;\n          }\n\n          terms.splice(i, 1);\n          i--;\n        } else {\n          if (subgroupStart !== -1 && i - subgroupStart > 1) {\n            terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));\n            i = subgroupStart + 1;\n          }\n\n          subgroupStart = -1;\n        }\n      }\n    }\n\n    if (subgroupStart !== -1 && combinators.length) {\n      terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));\n    }\n  }\n\n  return combinator;\n}\n\nfunction readImplicitGroup(tokenizer) {\n  var terms = [];\n  var combinators = {};\n  var token;\n  var prevToken = null;\n  var prevTokenPos = tokenizer.pos;\n\n  while (token = peek(tokenizer)) {\n    if (token.type !== 'Spaces') {\n      if (token.type === 'Combinator') {\n        // check for combinator in group beginning and double combinator sequence\n        if (prevToken === null || prevToken.type === 'Combinator') {\n          tokenizer.pos = prevTokenPos;\n          tokenizer.error('Unexpected combinator');\n        }\n\n        combinators[token.value] = true;\n      } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n        combinators[' '] = true; // a b\n\n        terms.push({\n          type: 'Combinator',\n          value: ' '\n        });\n      }\n\n      terms.push(token);\n      prevToken = token;\n      prevTokenPos = tokenizer.pos;\n    }\n  } // check for combinator in group ending\n\n\n  if (prevToken !== null && prevToken.type === 'Combinator') {\n    tokenizer.pos -= prevTokenPos;\n    tokenizer.error('Unexpected combinator');\n  }\n\n  return {\n    type: 'Group',\n    terms: terms,\n    combinator: regroupTerms(terms, combinators) || ' ',\n    disallowEmpty: false,\n    explicit: false\n  };\n}\n\nfunction readGroup(tokenizer) {\n  var result;\n  tokenizer.eat(LEFTSQUAREBRACKET);\n  result = readImplicitGroup(tokenizer);\n  tokenizer.eat(RIGHTSQUAREBRACKET);\n  result.explicit = true;\n\n  if (tokenizer.charCode() === EXCLAMATIONMARK) {\n    tokenizer.pos++;\n    result.disallowEmpty = true;\n  }\n\n  return result;\n}\n\nfunction peek(tokenizer) {\n  var code = tokenizer.charCode();\n\n  if (code < 128 && NAME_CHAR[code] === 1) {\n    return readKeywordOrFunction(tokenizer);\n  }\n\n  switch (code) {\n    case RIGHTSQUAREBRACKET:\n      // don't eat, stop scan a group\n      break;\n\n    case LEFTSQUAREBRACKET:\n      return maybeMultiplied(tokenizer, readGroup(tokenizer));\n\n    case LESSTHANSIGN:\n      return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);\n\n    case VERTICALLINE:\n      return {\n        type: 'Combinator',\n        value: tokenizer.substringToPos(tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1)\n      };\n\n    case AMPERSAND:\n      tokenizer.pos++;\n      tokenizer.eat(AMPERSAND);\n      return {\n        type: 'Combinator',\n        value: '&&'\n      };\n\n    case COMMA:\n      tokenizer.pos++;\n      return {\n        type: 'Comma'\n      };\n\n    case APOSTROPHE:\n      return maybeMultiplied(tokenizer, {\n        type: 'String',\n        value: scanString(tokenizer)\n      });\n\n    case SPACE:\n    case TAB:\n    case N:\n    case R:\n    case F:\n      return {\n        type: 'Spaces',\n        value: scanSpaces(tokenizer)\n      };\n\n    case COMMERCIALAT:\n      code = tokenizer.nextCharCode();\n\n      if (code < 128 && NAME_CHAR[code] === 1) {\n        tokenizer.pos++;\n        return {\n          type: 'AtKeyword',\n          name: scanWord(tokenizer)\n        };\n      }\n\n      return maybeToken(tokenizer);\n\n    case ASTERISK:\n    case PLUSSIGN:\n    case QUESTIONMARK:\n    case NUMBERSIGN:\n    case EXCLAMATIONMARK:\n      // prohibited tokens (used as a multiplier start)\n      break;\n\n    case LEFTCURLYBRACKET:\n      // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n      // check next char isn't a number, because it's likely a disjoined multiplier\n      code = tokenizer.nextCharCode();\n\n      if (code < 48 || code > 57) {\n        return maybeToken(tokenizer);\n      }\n\n      break;\n\n    default:\n      return maybeToken(tokenizer);\n  }\n}\n\nfunction parse(source) {\n  var tokenizer = new Tokenizer(source);\n  var result = readImplicitGroup(tokenizer);\n\n  if (tokenizer.pos !== source.length) {\n    tokenizer.error('Unexpected input');\n  } // reduce redundant groups with single group term\n\n\n  if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n    result = result.terms[0];\n  }\n\n  return result;\n} // warm up parse to elimitate code branches that never execute\n// fix soft deoptimizations (insufficient type feedback)\n\n\nparse('[a&&<b>#|<\\'c\\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');\nmodule.exports = parse;","map":{"version":3,"names":["Tokenizer","require","TAB","N","F","R","SPACE","EXCLAMATIONMARK","NUMBERSIGN","AMPERSAND","APOSTROPHE","LEFTPARENTHESIS","RIGHTPARENTHESIS","ASTERISK","PLUSSIGN","COMMA","HYPERMINUS","LESSTHANSIGN","GREATERTHANSIGN","QUESTIONMARK","COMMERCIALAT","LEFTSQUAREBRACKET","RIGHTSQUAREBRACKET","LEFTCURLYBRACKET","VERTICALLINE","RIGHTCURLYBRACKET","INFINITY","NAME_CHAR","createCharMap","ch","test","COMBINATOR_PRECEDENCE","fn","array","Uint32Array","Array","i","String","fromCharCode","scanSpaces","tokenizer","substringToPos","findWsEnd","pos","scanWord","end","str","length","code","charCodeAt","error","scanNumber","scanString","indexOf","readMultiplierRange","min","max","eat","charCode","Number","readMultiplier","range","comma","type","term","maybeMultiplied","node","multiplier","maybeToken","peek","value","readProperty","name","readTypeRange","sign","readType","opts","nextCharCode","readKeywordOrFunction","regroupTerms","terms","combinators","createGroup","combinator","disallowEmpty","explicit","Object","keys","sort","a","b","shift","subgroupStart","splice","slice","readImplicitGroup","token","prevToken","prevTokenPos","push","readGroup","result","parse","source","module","exports"],"sources":["/Users/nedanemati/Desktop/material-ui-github/node_modules/css-tree/lib/definition-syntax/parse.js"],"sourcesContent":["var Tokenizer = require('./tokenizer');\nvar TAB = 9;\nvar N = 10;\nvar F = 12;\nvar R = 13;\nvar SPACE = 32;\nvar EXCLAMATIONMARK = 33;    // !\nvar NUMBERSIGN = 35;         // #\nvar AMPERSAND = 38;          // &\nvar APOSTROPHE = 39;         // '\nvar LEFTPARENTHESIS = 40;    // (\nvar RIGHTPARENTHESIS = 41;   // )\nvar ASTERISK = 42;           // *\nvar PLUSSIGN = 43;           // +\nvar COMMA = 44;              // ,\nvar HYPERMINUS = 45;         // -\nvar LESSTHANSIGN = 60;       // <\nvar GREATERTHANSIGN = 62;    // >\nvar QUESTIONMARK = 63;       // ?\nvar COMMERCIALAT = 64;       // @\nvar LEFTSQUAREBRACKET = 91;  // [\nvar RIGHTSQUAREBRACKET = 93; // ]\nvar LEFTCURLYBRACKET = 123;  // {\nvar VERTICALLINE = 124;      // |\nvar RIGHTCURLYBRACKET = 125; // }\nvar INFINITY = 8734;         // ∞\nvar NAME_CHAR = createCharMap(function(ch) {\n    return /[a-zA-Z0-9\\-]/.test(ch);\n});\nvar COMBINATOR_PRECEDENCE = {\n    ' ': 1,\n    '&&': 2,\n    '||': 3,\n    '|': 4\n};\n\nfunction createCharMap(fn) {\n    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);\n    for (var i = 0; i < 128; i++) {\n        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;\n    }\n    return array;\n}\n\nfunction scanSpaces(tokenizer) {\n    return tokenizer.substringToPos(\n        tokenizer.findWsEnd(tokenizer.pos)\n    );\n}\n\nfunction scanWord(tokenizer) {\n    var end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        var code = tokenizer.str.charCodeAt(end);\n        if (code >= 128 || NAME_CHAR[code] === 0) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a keyword');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanNumber(tokenizer) {\n    var end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        var code = tokenizer.str.charCodeAt(end);\n        if (code < 48 || code > 57) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a number');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanString(tokenizer) {\n    var end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n\n    if (end === -1) {\n        tokenizer.pos = tokenizer.str.length;\n        tokenizer.error('Expect an apostrophe');\n    }\n\n    return tokenizer.substringToPos(end + 1);\n}\n\nfunction readMultiplierRange(tokenizer) {\n    var min = null;\n    var max = null;\n\n    tokenizer.eat(LEFTCURLYBRACKET);\n\n    min = scanNumber(tokenizer);\n\n    if (tokenizer.charCode() === COMMA) {\n        tokenizer.pos++;\n        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n            max = scanNumber(tokenizer);\n        }\n    } else {\n        max = min;\n    }\n\n    tokenizer.eat(RIGHTCURLYBRACKET);\n\n    return {\n        min: Number(min),\n        max: max ? Number(max) : 0\n    };\n}\n\nfunction readMultiplier(tokenizer) {\n    var range = null;\n    var comma = false;\n\n    switch (tokenizer.charCode()) {\n        case ASTERISK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 0\n            };\n\n            break;\n\n        case PLUSSIGN:\n            tokenizer.pos++;\n\n            range = {\n                min: 1,\n                max: 0\n            };\n\n            break;\n\n        case QUESTIONMARK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 1\n            };\n\n            break;\n\n        case NUMBERSIGN:\n            tokenizer.pos++;\n\n            comma = true;\n\n            if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n                range = readMultiplierRange(tokenizer);\n            } else {\n                range = {\n                    min: 1,\n                    max: 0\n                };\n            }\n\n            break;\n\n        case LEFTCURLYBRACKET:\n            range = readMultiplierRange(tokenizer);\n            break;\n\n        default:\n            return null;\n    }\n\n    return {\n        type: 'Multiplier',\n        comma: comma,\n        min: range.min,\n        max: range.max,\n        term: null\n    };\n}\n\nfunction maybeMultiplied(tokenizer, node) {\n    var multiplier = readMultiplier(tokenizer);\n\n    if (multiplier !== null) {\n        multiplier.term = node;\n        return multiplier;\n    }\n\n    return node;\n}\n\nfunction maybeToken(tokenizer) {\n    var ch = tokenizer.peek();\n\n    if (ch === '') {\n        return null;\n    }\n\n    return {\n        type: 'Token',\n        value: ch\n    };\n}\n\nfunction readProperty(tokenizer) {\n    var name;\n\n    tokenizer.eat(LESSTHANSIGN);\n    tokenizer.eat(APOSTROPHE);\n\n    name = scanWord(tokenizer);\n\n    tokenizer.eat(APOSTROPHE);\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Property',\n        name: name\n    });\n}\n\n// https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation—[min,max]—within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\nfunction readTypeRange(tokenizer) {\n    // use null for Infinity to make AST format JSON serializable/deserializable\n    var min = null; // -Infinity\n    var max = null; // Infinity\n    var sign = 1;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n\n    if (tokenizer.charCode() === HYPERMINUS) {\n        tokenizer.peek();\n        sign = -1;\n    }\n\n    if (sign == -1 && tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        min = sign * Number(scanNumber(tokenizer));\n    }\n\n    scanSpaces(tokenizer);\n    tokenizer.eat(COMMA);\n    scanSpaces(tokenizer);\n\n    if (tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        sign = 1;\n\n        if (tokenizer.charCode() === HYPERMINUS) {\n            tokenizer.peek();\n            sign = -1;\n        }\n\n        max = sign * Number(scanNumber(tokenizer));\n    }\n\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    // If no range is indicated, either by using the bracketed range notation\n    // or in the property description, then [−∞,∞] is assumed.\n    if (min === null && max === null) {\n        return null;\n    }\n\n    return {\n        type: 'Range',\n        min: min,\n        max: max\n    };\n}\n\nfunction readType(tokenizer) {\n    var name;\n    var opts = null;\n\n    tokenizer.eat(LESSTHANSIGN);\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS &&\n        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n        tokenizer.pos += 2;\n        name += '()';\n    }\n\n    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n        scanSpaces(tokenizer);\n        opts = readTypeRange(tokenizer);\n    }\n\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Type',\n        name: name,\n        opts: opts\n    });\n}\n\nfunction readKeywordOrFunction(tokenizer) {\n    var name;\n\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS) {\n        tokenizer.pos++;\n\n        return {\n            type: 'Function',\n            name: name\n        };\n    }\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Keyword',\n        name: name\n    });\n}\n\nfunction regroupTerms(terms, combinators) {\n    function createGroup(terms, combinator) {\n        return {\n            type: 'Group',\n            terms: terms,\n            combinator: combinator,\n            disallowEmpty: false,\n            explicit: false\n        };\n    }\n\n    combinators = Object.keys(combinators).sort(function(a, b) {\n        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];\n    });\n\n    while (combinators.length > 0) {\n        var combinator = combinators.shift();\n        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {\n            var term = terms[i];\n            if (term.type === 'Combinator') {\n                if (term.value === combinator) {\n                    if (subgroupStart === -1) {\n                        subgroupStart = i - 1;\n                    }\n                    terms.splice(i, 1);\n                    i--;\n                } else {\n                    if (subgroupStart !== -1 && i - subgroupStart > 1) {\n                        terms.splice(\n                            subgroupStart,\n                            i - subgroupStart,\n                            createGroup(terms.slice(subgroupStart, i), combinator)\n                        );\n                        i = subgroupStart + 1;\n                    }\n                    subgroupStart = -1;\n                }\n            }\n        }\n\n        if (subgroupStart !== -1 && combinators.length) {\n            terms.splice(\n                subgroupStart,\n                i - subgroupStart,\n                createGroup(terms.slice(subgroupStart, i), combinator)\n            );\n        }\n    }\n\n    return combinator;\n}\n\nfunction readImplicitGroup(tokenizer) {\n    var terms = [];\n    var combinators = {};\n    var token;\n    var prevToken = null;\n    var prevTokenPos = tokenizer.pos;\n\n    while (token = peek(tokenizer)) {\n        if (token.type !== 'Spaces') {\n            if (token.type === 'Combinator') {\n                // check for combinator in group beginning and double combinator sequence\n                if (prevToken === null || prevToken.type === 'Combinator') {\n                    tokenizer.pos = prevTokenPos;\n                    tokenizer.error('Unexpected combinator');\n                }\n\n                combinators[token.value] = true;\n            } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n                combinators[' '] = true;  // a b\n                terms.push({\n                    type: 'Combinator',\n                    value: ' '\n                });\n            }\n\n            terms.push(token);\n            prevToken = token;\n            prevTokenPos = tokenizer.pos;\n        }\n    }\n\n    // check for combinator in group ending\n    if (prevToken !== null && prevToken.type === 'Combinator') {\n        tokenizer.pos -= prevTokenPos;\n        tokenizer.error('Unexpected combinator');\n    }\n\n    return {\n        type: 'Group',\n        terms: terms,\n        combinator: regroupTerms(terms, combinators) || ' ',\n        disallowEmpty: false,\n        explicit: false\n    };\n}\n\nfunction readGroup(tokenizer) {\n    var result;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n    result = readImplicitGroup(tokenizer);\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    result.explicit = true;\n\n    if (tokenizer.charCode() === EXCLAMATIONMARK) {\n        tokenizer.pos++;\n        result.disallowEmpty = true;\n    }\n\n    return result;\n}\n\nfunction peek(tokenizer) {\n    var code = tokenizer.charCode();\n\n    if (code < 128 && NAME_CHAR[code] === 1) {\n        return readKeywordOrFunction(tokenizer);\n    }\n\n    switch (code) {\n        case RIGHTSQUAREBRACKET:\n            // don't eat, stop scan a group\n            break;\n\n        case LEFTSQUAREBRACKET:\n            return maybeMultiplied(tokenizer, readGroup(tokenizer));\n\n        case LESSTHANSIGN:\n            return tokenizer.nextCharCode() === APOSTROPHE\n                ? readProperty(tokenizer)\n                : readType(tokenizer);\n\n        case VERTICALLINE:\n            return {\n                type: 'Combinator',\n                value: tokenizer.substringToPos(\n                    tokenizer.nextCharCode() === VERTICALLINE\n                        ? tokenizer.pos + 2\n                        : tokenizer.pos + 1\n                )\n            };\n\n        case AMPERSAND:\n            tokenizer.pos++;\n            tokenizer.eat(AMPERSAND);\n\n            return {\n                type: 'Combinator',\n                value: '&&'\n            };\n\n        case COMMA:\n            tokenizer.pos++;\n            return {\n                type: 'Comma'\n            };\n\n        case APOSTROPHE:\n            return maybeMultiplied(tokenizer, {\n                type: 'String',\n                value: scanString(tokenizer)\n            });\n\n        case SPACE:\n        case TAB:\n        case N:\n        case R:\n        case F:\n            return {\n                type: 'Spaces',\n                value: scanSpaces(tokenizer)\n            };\n\n        case COMMERCIALAT:\n            code = tokenizer.nextCharCode();\n\n            if (code < 128 && NAME_CHAR[code] === 1) {\n                tokenizer.pos++;\n                return {\n                    type: 'AtKeyword',\n                    name: scanWord(tokenizer)\n                };\n            }\n\n            return maybeToken(tokenizer);\n\n        case ASTERISK:\n        case PLUSSIGN:\n        case QUESTIONMARK:\n        case NUMBERSIGN:\n        case EXCLAMATIONMARK:\n            // prohibited tokens (used as a multiplier start)\n            break;\n\n        case LEFTCURLYBRACKET:\n            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n            // check next char isn't a number, because it's likely a disjoined multiplier\n            code = tokenizer.nextCharCode();\n\n            if (code < 48 || code > 57) {\n                return maybeToken(tokenizer);\n            }\n\n            break;\n\n        default:\n            return maybeToken(tokenizer);\n    }\n}\n\nfunction parse(source) {\n    var tokenizer = new Tokenizer(source);\n    var result = readImplicitGroup(tokenizer);\n\n    if (tokenizer.pos !== source.length) {\n        tokenizer.error('Unexpected input');\n    }\n\n    // reduce redundant groups with single group term\n    if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n        result = result.terms[0];\n    }\n\n    return result;\n}\n\n// warm up parse to elimitate code branches that never execute\n// fix soft deoptimizations (insufficient type feedback)\nparse('[a&&<b>#|<\\'c\\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');\n\nmodule.exports = parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}