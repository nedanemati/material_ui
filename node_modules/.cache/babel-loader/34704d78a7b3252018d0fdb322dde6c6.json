{"ast":null,"code":"var hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar matchGraph = require('./match-graph');\n\nvar MATCH = matchGraph.MATCH;\nvar MISMATCH = matchGraph.MISMATCH;\nvar DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;\n\nvar TYPE = require('../tokenizer/const').TYPE;\n\nvar STUB = 0;\nvar TOKEN = 1;\nvar OPEN_SYNTAX = 2;\nvar CLOSE_SYNTAX = 3;\nvar EXIT_REASON_MATCH = 'Match';\nvar EXIT_REASON_MISMATCH = 'Mismatch';\nvar EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\nvar ITERATION_LIMIT = 15000;\nvar totalIterationCount = 0;\n\nfunction reverseList(list) {\n  var prev = null;\n  var next = null;\n  var item = list;\n\n  while (item !== null) {\n    next = item.prev;\n    item.prev = prev;\n    prev = item;\n    item = next;\n  }\n\n  return prev;\n}\n\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n  if (testStr.length !== referenceStr.length) {\n    return false;\n  }\n\n  for (var i = 0; i < testStr.length; i++) {\n    var testCode = testStr.charCodeAt(i);\n    var referenceCode = referenceStr.charCodeAt(i); // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n\n    if (testCode >= 0x0041 && testCode <= 0x005A) {\n      testCode = testCode | 32;\n    }\n\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isCommaContextStart(token) {\n  if (token === null) {\n    return true;\n  }\n\n  return token.type === TYPE.Comma || token.type === TYPE.Function || token.type === TYPE.LeftParenthesis || token.type === TYPE.LeftSquareBracket || token.type === TYPE.LeftCurlyBracket || token.type === TYPE.Delim;\n}\n\nfunction isCommaContextEnd(token) {\n  if (token === null) {\n    return true;\n  }\n\n  return token.type === TYPE.RightParenthesis || token.type === TYPE.RightSquareBracket || token.type === TYPE.RightCurlyBracket || token.type === TYPE.Delim;\n}\n\nfunction internalMatch(tokens, state, syntaxes) {\n  function moveToNextToken() {\n    do {\n      tokenIndex++;\n      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n    } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n  }\n\n  function getNextToken(offset) {\n    var nextIndex = tokenIndex + offset;\n    return nextIndex < tokens.length ? tokens[nextIndex] : null;\n  }\n\n  function stateSnapshotFromSyntax(nextState, prev) {\n    return {\n      nextState: nextState,\n      matchStack: matchStack,\n      syntaxStack: syntaxStack,\n      thenStack: thenStack,\n      tokenIndex: tokenIndex,\n      prev: prev\n    };\n  }\n\n  function pushThenStack(nextState) {\n    thenStack = {\n      nextState: nextState,\n      matchStack: matchStack,\n      syntaxStack: syntaxStack,\n      prev: thenStack\n    };\n  }\n\n  function pushElseStack(nextState) {\n    elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n  }\n\n  function addTokenToMatch() {\n    matchStack = {\n      type: TOKEN,\n      syntax: state.syntax,\n      token: token,\n      prev: matchStack\n    };\n    moveToNextToken();\n    syntaxStash = null;\n\n    if (tokenIndex > longestMatch) {\n      longestMatch = tokenIndex;\n    }\n  }\n\n  function openSyntax() {\n    syntaxStack = {\n      syntax: state.syntax,\n      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,\n      prev: syntaxStack\n    };\n    matchStack = {\n      type: OPEN_SYNTAX,\n      syntax: state.syntax,\n      token: matchStack.token,\n      prev: matchStack\n    };\n  }\n\n  function closeSyntax() {\n    if (matchStack.type === OPEN_SYNTAX) {\n      matchStack = matchStack.prev;\n    } else {\n      matchStack = {\n        type: CLOSE_SYNTAX,\n        syntax: syntaxStack.syntax,\n        token: matchStack.token,\n        prev: matchStack\n      };\n    }\n\n    syntaxStack = syntaxStack.prev;\n  }\n\n  var syntaxStack = null;\n  var thenStack = null;\n  var elseStack = null; // null – stashing allowed, nothing stashed\n  // false – stashing disabled, nothing stashed\n  // anithing else – fail stashable syntaxes, some syntax stashed\n\n  var syntaxStash = null;\n  var iterationCount = 0; // count iterations and prevent infinite loop\n\n  var exitReason = null;\n  var token = null;\n  var tokenIndex = -1;\n  var longestMatch = 0;\n  var matchStack = {\n    type: STUB,\n    syntax: null,\n    token: null,\n    prev: null\n  };\n  moveToNextToken();\n\n  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n    // function mapList(list, fn) {\n    //     var result = [];\n    //     while (list) {\n    //         result.unshift(fn(list));\n    //         list = list.prev;\n    //     }\n    //     return result;\n    // }\n    // console.log('--\\n',\n    //     '#' + iterationCount,\n    //     require('util').inspect({\n    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n    //         token: token && token.value,\n    //         tokenIndex,\n    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n    //     }, { depth: null })\n    // );\n    switch (state.type) {\n      case 'Match':\n        if (thenStack === null) {\n          // turn to MISMATCH when some tokens left unmatched\n          if (token !== null) {\n            // doesn't mismatch if just one token left and it's an IE hack\n            if (tokenIndex !== tokens.length - 1 || token.value !== '\\\\0' && token.value !== '\\\\9') {\n              state = MISMATCH;\n              break;\n            }\n          } // break the main loop, return a result - MATCH\n\n\n          exitReason = EXIT_REASON_MATCH;\n          break;\n        } // go to next syntax (`then` branch)\n\n\n        state = thenStack.nextState; // check match is not empty\n\n        if (state === DISALLOW_EMPTY) {\n          if (thenStack.matchStack === matchStack) {\n            state = MISMATCH;\n            break;\n          } else {\n            state = MATCH;\n          }\n        } // close syntax if needed\n\n\n        while (thenStack.syntaxStack !== syntaxStack) {\n          closeSyntax();\n        } // pop stack\n\n\n        thenStack = thenStack.prev;\n        break;\n\n      case 'Mismatch':\n        // when some syntax is stashed\n        if (syntaxStash !== null && syntaxStash !== false) {\n          // there is no else branches or a branch reduce match stack\n          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n            // restore state from the stash\n            elseStack = syntaxStash;\n            syntaxStash = false; // disable stashing\n          }\n        } else if (elseStack === null) {\n          // no else branches -> break the main loop\n          // return a result - MISMATCH\n          exitReason = EXIT_REASON_MISMATCH;\n          break;\n        } // go to next syntax (`else` branch)\n\n\n        state = elseStack.nextState; // restore all the rest stack states\n\n        thenStack = elseStack.thenStack;\n        syntaxStack = elseStack.syntaxStack;\n        matchStack = elseStack.matchStack;\n        tokenIndex = elseStack.tokenIndex;\n        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null; // pop stack\n\n        elseStack = elseStack.prev;\n        break;\n\n      case 'MatchGraph':\n        state = state.match;\n        break;\n\n      case 'If':\n        // IMPORTANT: else stack push must go first,\n        // since it stores the state of thenStack before changes\n        if (state.else !== MISMATCH) {\n          pushElseStack(state.else);\n        }\n\n        if (state.then !== MATCH) {\n          pushThenStack(state.then);\n        }\n\n        state = state.match;\n        break;\n\n      case 'MatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state,\n          index: 0,\n          mask: 0\n        };\n        break;\n\n      case 'MatchOnceBuffer':\n        var terms = state.syntax.terms;\n\n        if (state.index === terms.length) {\n          // no matches at all or it's required all terms to be matched\n          if (state.mask === 0 || state.syntax.all) {\n            state = MISMATCH;\n            break;\n          } // a partial match is ok\n\n\n          state = MATCH;\n          break;\n        } // all terms are matched\n\n\n        if (state.mask === (1 << terms.length) - 1) {\n          state = MATCH;\n          break;\n        }\n\n        for (; state.index < terms.length; state.index++) {\n          var matchFlag = 1 << state.index;\n\n          if ((state.mask & matchFlag) === 0) {\n            // IMPORTANT: else stack push must go first,\n            // since it stores the state of thenStack before changes\n            pushElseStack(state);\n            pushThenStack({\n              type: 'AddMatchOnce',\n              syntax: state.syntax,\n              mask: state.mask | matchFlag\n            }); // match\n\n            state = terms[state.index++];\n            break;\n          }\n        }\n\n        break;\n\n      case 'AddMatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state.syntax,\n          index: 0,\n          mask: state.mask\n        };\n        break;\n\n      case 'Enum':\n        if (token !== null) {\n          var name = token.value.toLowerCase(); // drop \\0 and \\9 hack from keyword name\n\n          if (name.indexOf('\\\\') !== -1) {\n            name = name.replace(/\\\\[09].*$/, '');\n          }\n\n          if (hasOwnProperty.call(state.map, name)) {\n            state = state.map[name];\n            break;\n          }\n        }\n\n        state = MISMATCH;\n        break;\n\n      case 'Generic':\n        var opts = syntaxStack !== null ? syntaxStack.opts : null;\n        var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n        if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n\n          state = MATCH;\n        } else {\n          state = MISMATCH;\n        }\n\n        break;\n\n      case 'Type':\n      case 'Property':\n        var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n        var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n        if (!dictSyntax || !dictSyntax.match) {\n          throw new Error('Bad syntax reference: ' + (state.type === 'Type' ? '<' + state.name + '>' : '<\\'' + state.name + '\\'>'));\n        } // stash a syntax for types with low priority\n\n\n        if (syntaxStash !== false && token !== null && state.type === 'Type') {\n          var lowPriorityMatching = // https://drafts.csswg.org/css-values-4/#custom-idents\n          // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n          // can only claim the keyword if no other unfulfilled production can claim it.\n          state.name === 'custom-ident' && token.type === TYPE.Ident || // https://drafts.csswg.org/css-values-4/#lengths\n          // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n          // it must parse as a <number>\n          state.name === 'length' && token.value === '0';\n\n          if (lowPriorityMatching) {\n            if (syntaxStash === null) {\n              syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n            }\n\n            state = MISMATCH;\n            break;\n          }\n        }\n\n        openSyntax();\n        state = dictSyntax.match;\n        break;\n\n      case 'Keyword':\n        var name = state.name;\n\n        if (token !== null) {\n          var keywordName = token.value; // drop \\0 and \\9 hack from keyword name\n\n          if (keywordName.indexOf('\\\\') !== -1) {\n            keywordName = keywordName.replace(/\\\\[09].*$/, '');\n          }\n\n          if (areStringsEqualCaseInsensitive(keywordName, name)) {\n            addTokenToMatch();\n            state = MATCH;\n            break;\n          }\n        }\n\n        state = MISMATCH;\n        break;\n\n      case 'AtKeyword':\n      case 'Function':\n        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n          addTokenToMatch();\n          state = MATCH;\n          break;\n        }\n\n        state = MISMATCH;\n        break;\n\n      case 'Token':\n        if (token !== null && token.value === state.value) {\n          addTokenToMatch();\n          state = MATCH;\n          break;\n        }\n\n        state = MISMATCH;\n        break;\n\n      case 'Comma':\n        if (token !== null && token.type === TYPE.Comma) {\n          if (isCommaContextStart(matchStack.token)) {\n            state = MISMATCH;\n          } else {\n            addTokenToMatch();\n            state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n          }\n        } else {\n          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n        }\n\n        break;\n\n      case 'String':\n        var string = '';\n\n        for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n          string += tokens[lastTokenIndex].value;\n        }\n\n        if (areStringsEqualCaseInsensitive(string, state.value)) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n\n          state = MATCH;\n        } else {\n          state = MISMATCH;\n        }\n\n        break;\n\n      default:\n        throw new Error('Unknown node type: ' + state.type);\n    }\n  }\n\n  totalIterationCount += iterationCount;\n\n  switch (exitReason) {\n    case null:\n      console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n      exitReason = EXIT_REASON_ITERATION_LIMIT;\n      matchStack = null;\n      break;\n\n    case EXIT_REASON_MATCH:\n      while (syntaxStack !== null) {\n        closeSyntax();\n      }\n\n      break;\n\n    default:\n      matchStack = null;\n  }\n\n  return {\n    tokens: tokens,\n    reason: exitReason,\n    iterations: iterationCount,\n    match: matchStack,\n    longestMatch: longestMatch\n  };\n}\n\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n  if (matchResult.match !== null) {\n    var item = reverseList(matchResult.match).prev;\n    matchResult.match = [];\n\n    while (item !== null) {\n      switch (item.type) {\n        case STUB:\n          break;\n\n        case OPEN_SYNTAX:\n        case CLOSE_SYNTAX:\n          matchResult.match.push({\n            type: item.type,\n            syntax: item.syntax\n          });\n          break;\n\n        default:\n          matchResult.match.push({\n            token: item.token.value,\n            node: item.token.node\n          });\n          break;\n      }\n\n      item = item.prev;\n    }\n  }\n\n  return matchResult;\n}\n\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n  if (matchResult.match === null) {\n    return matchResult;\n  }\n\n  var item = matchResult.match;\n  var host = matchResult.match = {\n    syntax: matchGraph.syntax || null,\n    match: []\n  };\n  var hostStack = [host]; // revert a list and start with 2nd item since 1st is a stub item\n\n  item = reverseList(item).prev; // build a tree\n\n  while (item !== null) {\n    switch (item.type) {\n      case OPEN_SYNTAX:\n        host.match.push(host = {\n          syntax: item.syntax,\n          match: []\n        });\n        hostStack.push(host);\n        break;\n\n      case CLOSE_SYNTAX:\n        hostStack.pop();\n        host = hostStack[hostStack.length - 1];\n        break;\n\n      default:\n        host.match.push({\n          syntax: item.syntax || null,\n          token: item.token.value,\n          node: item.token.node\n        });\n    }\n\n    item = item.prev;\n  }\n\n  return matchResult;\n}\n\nmodule.exports = {\n  matchAsList: matchAsList,\n  matchAsTree: matchAsTree,\n  getTotalIterationCount: function () {\n    return totalIterationCount;\n  }\n};","map":{"version":3,"names":["hasOwnProperty","Object","prototype","matchGraph","require","MATCH","MISMATCH","DISALLOW_EMPTY","TYPE","STUB","TOKEN","OPEN_SYNTAX","CLOSE_SYNTAX","EXIT_REASON_MATCH","EXIT_REASON_MISMATCH","EXIT_REASON_ITERATION_LIMIT","ITERATION_LIMIT","totalIterationCount","reverseList","list","prev","next","item","areStringsEqualCaseInsensitive","testStr","referenceStr","length","i","testCode","charCodeAt","referenceCode","isCommaContextStart","token","type","Comma","Function","LeftParenthesis","LeftSquareBracket","LeftCurlyBracket","Delim","isCommaContextEnd","RightParenthesis","RightSquareBracket","RightCurlyBracket","internalMatch","tokens","state","syntaxes","moveToNextToken","tokenIndex","WhiteSpace","Comment","getNextToken","offset","nextIndex","stateSnapshotFromSyntax","nextState","matchStack","syntaxStack","thenStack","pushThenStack","pushElseStack","elseStack","addTokenToMatch","syntax","syntaxStash","longestMatch","openSyntax","opts","closeSyntax","iterationCount","exitReason","value","match","else","then","index","mask","terms","all","matchFlag","name","toLowerCase","indexOf","replace","call","map","lastTokenIndex","Math","floor","fn","isNaN","syntaxDict","dictSyntax","Error","lowPriorityMatching","Ident","keywordName","string","console","warn","reason","iterations","matchAsList","matchResult","push","node","matchAsTree","host","hostStack","pop","module","exports","getTotalIterationCount"],"sources":["/Users/nedanemati/Desktop/material-ui-github/node_modules/css-tree/lib/lexer/match.js"],"sourcesContent":["var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar matchGraph = require('./match-graph');\nvar MATCH = matchGraph.MATCH;\nvar MISMATCH = matchGraph.MISMATCH;\nvar DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;\nvar TYPE = require('../tokenizer/const').TYPE;\n\nvar STUB = 0;\nvar TOKEN = 1;\nvar OPEN_SYNTAX = 2;\nvar CLOSE_SYNTAX = 3;\n\nvar EXIT_REASON_MATCH = 'Match';\nvar EXIT_REASON_MISMATCH = 'Mismatch';\nvar EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\n\nvar ITERATION_LIMIT = 15000;\nvar totalIterationCount = 0;\n\nfunction reverseList(list) {\n    var prev = null;\n    var next = null;\n    var item = list;\n\n    while (item !== null) {\n        next = item.prev;\n        item.prev = prev;\n        prev = item;\n        item = next;\n    }\n\n    return prev;\n}\n\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n    if (testStr.length !== referenceStr.length) {\n        return false;\n    }\n\n    for (var i = 0; i < testStr.length; i++) {\n        var testCode = testStr.charCodeAt(i);\n        var referenceCode = referenceStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n        if (testCode >= 0x0041 && testCode <= 0x005A) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction isCommaContextStart(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.Comma ||\n        token.type === TYPE.Function ||\n        token.type === TYPE.LeftParenthesis ||\n        token.type === TYPE.LeftSquareBracket ||\n        token.type === TYPE.LeftCurlyBracket ||\n        token.type === TYPE.Delim\n    );\n}\n\nfunction isCommaContextEnd(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.RightParenthesis ||\n        token.type === TYPE.RightSquareBracket ||\n        token.type === TYPE.RightCurlyBracket ||\n        token.type === TYPE.Delim\n    );\n}\n\nfunction internalMatch(tokens, state, syntaxes) {\n    function moveToNextToken() {\n        do {\n            tokenIndex++;\n            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n    }\n\n    function getNextToken(offset) {\n        var nextIndex = tokenIndex + offset;\n\n        return nextIndex < tokens.length ? tokens[nextIndex] : null;\n    }\n\n    function stateSnapshotFromSyntax(nextState, prev) {\n        return {\n            nextState: nextState,\n            matchStack: matchStack,\n            syntaxStack: syntaxStack,\n            thenStack: thenStack,\n            tokenIndex: tokenIndex,\n            prev: prev\n        };\n    }\n\n    function pushThenStack(nextState) {\n        thenStack = {\n            nextState: nextState,\n            matchStack: matchStack,\n            syntaxStack: syntaxStack,\n            prev: thenStack\n        };\n    }\n\n    function pushElseStack(nextState) {\n        elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n    }\n\n    function addTokenToMatch() {\n        matchStack = {\n            type: TOKEN,\n            syntax: state.syntax,\n            token: token,\n            prev: matchStack\n        };\n\n        moveToNextToken();\n        syntaxStash = null;\n\n        if (tokenIndex > longestMatch) {\n            longestMatch = tokenIndex;\n        }\n    }\n\n    function openSyntax() {\n        syntaxStack = {\n            syntax: state.syntax,\n            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,\n            prev: syntaxStack\n        };\n\n        matchStack = {\n            type: OPEN_SYNTAX,\n            syntax: state.syntax,\n            token: matchStack.token,\n            prev: matchStack\n        };\n    }\n\n    function closeSyntax() {\n        if (matchStack.type === OPEN_SYNTAX) {\n            matchStack = matchStack.prev;\n        } else {\n            matchStack = {\n                type: CLOSE_SYNTAX,\n                syntax: syntaxStack.syntax,\n                token: matchStack.token,\n                prev: matchStack\n            };\n        }\n\n        syntaxStack = syntaxStack.prev;\n    }\n\n    var syntaxStack = null;\n    var thenStack = null;\n    var elseStack = null;\n\n    // null – stashing allowed, nothing stashed\n    // false – stashing disabled, nothing stashed\n    // anithing else – fail stashable syntaxes, some syntax stashed\n    var syntaxStash = null;\n\n    var iterationCount = 0; // count iterations and prevent infinite loop\n    var exitReason = null;\n\n    var token = null;\n    var tokenIndex = -1;\n    var longestMatch = 0;\n    var matchStack = {\n        type: STUB,\n        syntax: null,\n        token: null,\n        prev: null\n    };\n\n    moveToNextToken();\n\n    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n        // function mapList(list, fn) {\n        //     var result = [];\n        //     while (list) {\n        //         result.unshift(fn(list));\n        //         list = list.prev;\n        //     }\n        //     return result;\n        // }\n        // console.log('--\\n',\n        //     '#' + iterationCount,\n        //     require('util').inspect({\n        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n        //         token: token && token.value,\n        //         tokenIndex,\n        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n        //     }, { depth: null })\n        // );\n        switch (state.type) {\n            case 'Match':\n                if (thenStack === null) {\n                    // turn to MISMATCH when some tokens left unmatched\n                    if (token !== null) {\n                        // doesn't mismatch if just one token left and it's an IE hack\n                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\\\0' && token.value !== '\\\\9')) {\n                            state = MISMATCH;\n                            break;\n                        }\n                    }\n\n                    // break the main loop, return a result - MATCH\n                    exitReason = EXIT_REASON_MATCH;\n                    break;\n                }\n\n                // go to next syntax (`then` branch)\n                state = thenStack.nextState;\n\n                // check match is not empty\n                if (state === DISALLOW_EMPTY) {\n                    if (thenStack.matchStack === matchStack) {\n                        state = MISMATCH;\n                        break;\n                    } else {\n                        state = MATCH;\n                    }\n                }\n\n                // close syntax if needed\n                while (thenStack.syntaxStack !== syntaxStack) {\n                    closeSyntax();\n                }\n\n                // pop stack\n                thenStack = thenStack.prev;\n                break;\n\n            case 'Mismatch':\n                // when some syntax is stashed\n                if (syntaxStash !== null && syntaxStash !== false) {\n                    // there is no else branches or a branch reduce match stack\n                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n                        // restore state from the stash\n                        elseStack = syntaxStash;\n                        syntaxStash = false; // disable stashing\n                    }\n                } else if (elseStack === null) {\n                    // no else branches -> break the main loop\n                    // return a result - MISMATCH\n                    exitReason = EXIT_REASON_MISMATCH;\n                    break;\n                }\n\n                // go to next syntax (`else` branch)\n                state = elseStack.nextState;\n\n                // restore all the rest stack states\n                thenStack = elseStack.thenStack;\n                syntaxStack = elseStack.syntaxStack;\n                matchStack = elseStack.matchStack;\n                tokenIndex = elseStack.tokenIndex;\n                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n                // pop stack\n                elseStack = elseStack.prev;\n                break;\n\n            case 'MatchGraph':\n                state = state.match;\n                break;\n\n            case 'If':\n                // IMPORTANT: else stack push must go first,\n                // since it stores the state of thenStack before changes\n                if (state.else !== MISMATCH) {\n                    pushElseStack(state.else);\n                }\n\n                if (state.then !== MATCH) {\n                    pushThenStack(state.then);\n                }\n\n                state = state.match;\n                break;\n\n            case 'MatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state,\n                    index: 0,\n                    mask: 0\n                };\n                break;\n\n            case 'MatchOnceBuffer':\n                var terms = state.syntax.terms;\n\n                if (state.index === terms.length) {\n                    // no matches at all or it's required all terms to be matched\n                    if (state.mask === 0 || state.syntax.all) {\n                        state = MISMATCH;\n                        break;\n                    }\n\n                    // a partial match is ok\n                    state = MATCH;\n                    break;\n                }\n\n                // all terms are matched\n                if (state.mask === (1 << terms.length) - 1) {\n                    state = MATCH;\n                    break;\n                }\n\n                for (; state.index < terms.length; state.index++) {\n                    var matchFlag = 1 << state.index;\n\n                    if ((state.mask & matchFlag) === 0) {\n                        // IMPORTANT: else stack push must go first,\n                        // since it stores the state of thenStack before changes\n                        pushElseStack(state);\n                        pushThenStack({\n                            type: 'AddMatchOnce',\n                            syntax: state.syntax,\n                            mask: state.mask | matchFlag\n                        });\n\n                        // match\n                        state = terms[state.index++];\n                        break;\n                    }\n                }\n                break;\n\n            case 'AddMatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state.syntax,\n                    index: 0,\n                    mask: state.mask\n                };\n                break;\n\n            case 'Enum':\n                if (token !== null) {\n                    var name = token.value.toLowerCase();\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (name.indexOf('\\\\') !== -1) {\n                        name = name.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (hasOwnProperty.call(state.map, name)) {\n                        state = state.map[name];\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Generic':\n                var opts = syntaxStack !== null ? syntaxStack.opts : null;\n                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            case 'Type':\n            case 'Property':\n                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n                var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n                if (!dictSyntax || !dictSyntax.match) {\n                    throw new Error(\n                        'Bad syntax reference: ' +\n                        (state.type === 'Type'\n                            ? '<' + state.name + '>'\n                            : '<\\'' + state.name + '\\'>')\n                    );\n                }\n\n                // stash a syntax for types with low priority\n                if (syntaxStash !== false && token !== null && state.type === 'Type') {\n                    var lowPriorityMatching =\n                        // https://drafts.csswg.org/css-values-4/#custom-idents\n                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n                        // can only claim the keyword if no other unfulfilled production can claim it.\n                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||\n\n                        // https://drafts.csswg.org/css-values-4/#lengths\n                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n                        // it must parse as a <number>\n                        (state.name === 'length' && token.value === '0');\n\n                    if (lowPriorityMatching) {\n                        if (syntaxStash === null) {\n                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n                        }\n\n                        state = MISMATCH;\n                        break;\n                    }\n                }\n\n                openSyntax();\n                state = dictSyntax.match;\n                break;\n\n            case 'Keyword':\n                var name = state.name;\n\n                if (token !== null) {\n                    var keywordName = token.value;\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (keywordName.indexOf('\\\\') !== -1) {\n                        keywordName = keywordName.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (areStringsEqualCaseInsensitive(keywordName, name)) {\n                        addTokenToMatch();\n                        state = MATCH;\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'AtKeyword':\n            case 'Function':\n                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Token':\n                if (token !== null && token.value === state.value) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Comma':\n                if (token !== null && token.type === TYPE.Comma) {\n                    if (isCommaContextStart(matchStack.token)) {\n                        state = MISMATCH;\n                    } else {\n                        addTokenToMatch();\n                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n                    }\n                } else {\n                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n                }\n\n                break;\n\n            case 'String':\n                var string = '';\n\n                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n                    string += tokens[lastTokenIndex].value;\n                }\n\n                if (areStringsEqualCaseInsensitive(string, state.value)) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            default:\n                throw new Error('Unknown node type: ' + state.type);\n        }\n    }\n\n    totalIterationCount += iterationCount;\n\n    switch (exitReason) {\n        case null:\n            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n            exitReason = EXIT_REASON_ITERATION_LIMIT;\n            matchStack = null;\n            break;\n\n        case EXIT_REASON_MATCH:\n            while (syntaxStack !== null) {\n                closeSyntax();\n            }\n            break;\n\n        default:\n            matchStack = null;\n    }\n\n    return {\n        tokens: tokens,\n        reason: exitReason,\n        iterations: iterationCount,\n        match: matchStack,\n        longestMatch: longestMatch\n    };\n}\n\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match !== null) {\n        var item = reverseList(matchResult.match).prev;\n\n        matchResult.match = [];\n\n        while (item !== null) {\n            switch (item.type) {\n                case STUB:\n                    break;\n\n                case OPEN_SYNTAX:\n                case CLOSE_SYNTAX:\n                    matchResult.match.push({\n                        type: item.type,\n                        syntax: item.syntax\n                    });\n                    break;\n\n                default:\n                    matchResult.match.push({\n                        token: item.token.value,\n                        node: item.token.node\n                    });\n                    break;\n            }\n\n            item = item.prev;\n        }\n    }\n\n    return matchResult;\n}\n\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match === null) {\n        return matchResult;\n    }\n\n    var item = matchResult.match;\n    var host = matchResult.match = {\n        syntax: matchGraph.syntax || null,\n        match: []\n    };\n    var hostStack = [host];\n\n    // revert a list and start with 2nd item since 1st is a stub item\n    item = reverseList(item).prev;\n\n    // build a tree\n    while (item !== null) {\n        switch (item.type) {\n            case OPEN_SYNTAX:\n                host.match.push(host = {\n                    syntax: item.syntax,\n                    match: []\n                });\n                hostStack.push(host);\n                break;\n\n            case CLOSE_SYNTAX:\n                hostStack.pop();\n                host = hostStack[hostStack.length - 1];\n                break;\n\n            default:\n                host.match.push({\n                    syntax: item.syntax || null,\n                    token: item.token.value,\n                    node: item.token.node\n                });\n        }\n\n        item = item.prev;\n    }\n\n    return matchResult;\n}\n\nmodule.exports = {\n    matchAsList: matchAsList,\n    matchAsTree: matchAsTree,\n    getTotalIterationCount: function() {\n        return totalIterationCount;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}